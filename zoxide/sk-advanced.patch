diff --git a/man/man1/zoxide-query.1 b/man/man1/zoxide-query.1
index e1ccd1d..880da60 100644
--- a/man/man1/zoxide-query.1
+++ b/man/man1/zoxide-query.1
@@ -18,7 +18,7 @@ Exclude a path from query results.
 Print help information.
 .TP
 .B -i, --interactive
-Use interactive selection. This option requires \fBfzf\fR(1).
+Use interactive selection. This option requires \fBfzf\fR(1) or \fBsk\fR(1).
 .TP
 .B -l, --list
 List all results, rather than just the one with the highest frecency.
diff --git a/man/man1/zoxide.1 b/man/man1/zoxide.1
index ef1792b..08bf16c 100644
--- a/man/man1/zoxide.1
+++ b/man/man1/zoxide.1
@@ -18,7 +18,7 @@ z foo/             # cd into relative path
 z ..               # cd one level up
 z -                # cd into previous directory
 .sp
-zi foo             # cd with interactive selection (using fzf)
+zi foo             # cd with interactive selection (using fzf or sk)
 .sp
 z foo<SPACE><TAB>  # show interactive completions (bash 4.4+/fish/zsh only)
 .fi
@@ -92,6 +92,10 @@ to use \fBzoxide-remove\fR(1) to remove any existing entries from the database.
 Custom options to pass to \fBfzf\fR(1) during interactive selection. See the
 manpage for the full list of options.
 .TP
+.B _ZO_SK_OPTS
+Custom options to pass to \fBsk\fR(1) during interactive selection. See the
+manpage for the full list of options.
+.TP
 .B _ZO_MAXAGE
 Configures the aging algorithm, which limits the maximum number of entries in
 the database. By default, this is set to 10000.
diff --git a/src/cmd/cmd.rs b/src/cmd/cmd.rs
index d25cda3..d7c01e7 100644
--- a/src/cmd/cmd.rs
+++ b/src/cmd/cmd.rs
@@ -26,6 +26,7 @@ https://github.com/ajeetdsouza/zoxide
 {tab}<bold>_ZO_ECHO</bold>            {tab}Print the matched directory before navigating to it when set to 1
 {tab}<bold>_ZO_EXCLUDE_DIRS</bold>    {tab}List of directory globs to be excluded
 {tab}<bold>_ZO_FZF_OPTS</bold>        {tab}Custom flags to pass to fzf
+{tab}<bold>_ZO_SK_OPTS</bold>         {tab}Custom flags to pass to sk
 {tab}<bold>_ZO_MAXAGE</bold>          {tab}Maximum total age after which entries start getting deleted
 {tab}<bold>_ZO_RESOLVE_SYMLINKS</bold>{tab}Resolve symlinks when storing paths").into_resettable()
     }
diff --git a/src/cmd/edit.rs b/src/cmd/edit.rs
index 0f37165..a92b3b8 100644
--- a/src/cmd/edit.rs
+++ b/src/cmd/edit.rs
@@ -5,7 +5,7 @@ use anyhow::Result;
 use crate::cmd::{Edit, EditCommand, Run};
 use crate::db::Database;
 use crate::error::BrokenPipeHandler;
-use crate::util::{self, Fzf, FzfChild};
+use crate::util::{self, Fzf, FzfChild, Sk, SkChild};
 
 impl Run for Edit {
     fn run(&self) -> Result<()> {
@@ -27,14 +27,19 @@ impl Run for Edit {
                 let stdout = &mut io::stdout().lock();
                 for dir in db.dirs().iter().rev() {
                     write!(stdout, "{}\0", dir.display().with_score(now).with_separator('\t'))
-                        .pipe_exit("fzf")?;
+                        .pipe_exit("fzf or sk")?;
                 }
                 Ok(())
             }
             None => {
                 db.sort_by_score(now);
                 db.save()?;
-                Self::get_fzf()?.wait()?;
+                let fzf = Self::get_fzf();
+                if let Ok(mut fzf) = fzf {
+                    fzf.wait()?;
+                    return Ok(());
+                }
+                Self::get_sk()?.wait()?;
                 Ok(())
             }
         }
@@ -81,4 +86,42 @@ ctrl-w:increment\tctrl-s:decrement
             .enable_preview()
             .spawn()
     }
+
+    fn get_sk() -> Result<SkChild> {
+        Sk::new()?
+            .args([
+                // Search mode
+                "--exact",
+                // Search result
+                "--no-sort",
+                // Interface
+                "--bind=\
+btab:up,\
+ctrl-r:reload(zoxide edit reload),\
+ctrl-d:reload(zoxide edit delete {2..}),\
+ctrl-w:reload(zoxide edit increment {2..}),\
+ctrl-s:reload(zoxide edit decrement {2..}),\
+ctrl-z:ignore,\
+double-click:ignore,\
+enter:abort,\
+start:reload(zoxide edit reload),\
+tab:down",
+                "--cycle",
+                "--keep-right",
+                // Layout
+                "--border=sharp",
+                "--header=\
+ctrl-r:reload   \tctrl-d:delete
+ctrl-w:increment\tctrl-s:decrement
+
+ SCORE\tPATH",
+                "--info=inline",
+                "--layout=reverse",
+                // Display
+                "--color=label:bold",
+                "--tabstop=1",
+            ])
+            .enable_preview()
+            .spawn()
+    }
 }
diff --git a/src/cmd/query.rs b/src/cmd/query.rs
index 362d80a..5b54995 100644
--- a/src/cmd/query.rs
+++ b/src/cmd/query.rs
@@ -6,7 +6,7 @@ use crate::cmd::{Query, Run};
 use crate::config;
 use crate::db::{Database, Epoch, Stream, StreamOptions};
 use crate::error::BrokenPipeHandler;
-use crate::util::{self, Fzf, FzfChild};
+use crate::util::{self, Fzf, FzfChild, Sk, SkChild};
 
 impl Run for Query {
     fn run(&self) -> Result<()> {
@@ -30,23 +30,45 @@ impl Query {
     }
 
     fn query_interactive(&self, stream: &mut Stream, now: Epoch) -> Result<()> {
-        let mut fzf = Self::get_fzf()?;
+        let fzf = Self::get_fzf();
+        if let Ok(mut fzf) = fzf {
+            let selection = loop {
+                match stream.next() {
+                    Some(dir) if Some(dir.path.as_ref()) == self.exclude.as_deref() => continue,
+                    Some(dir) => {
+                        if let Some(selection) = fzf.write(dir, now)? {
+                            break selection;
+                        }
+                    }
+                    None => break fzf.wait()?,
+                }
+            };
+
+            if self.score {
+                print!("{selection}");
+            } else {
+                let path = selection.get(7..).context("could not read selection from fzf")?;
+                print!("{path}");
+            }
+            return Ok(());
+        }
+        let mut sk = Self::get_sk()?;
         let selection = loop {
             match stream.next() {
                 Some(dir) if Some(dir.path.as_ref()) == self.exclude.as_deref() => continue,
                 Some(dir) => {
-                    if let Some(selection) = fzf.write(dir, now)? {
+                    if let Some(selection) = sk.write(dir, now)? {
                         break selection;
                     }
                 }
-                None => break fzf.wait()?,
+                None => break sk.wait()?,
             }
         };
 
         if self.score {
             print!("{selection}");
         } else {
-            let path = selection.get(7..).context("could not read selection from fzf")?;
+            let path = selection.get(7..).context("could not read selection from sk")?;
             print!("{path}");
         }
         Ok(())
@@ -117,4 +139,33 @@ impl Query {
         }
         .spawn()
     }
+
+    fn get_sk() -> Result<SkChild> {
+        let mut sk = Sk::new()?;
+        if let Some(sk_opts) = config::sk_opts() {
+            sk.env("SK_DEFAULT_OPTS", sk_opts)
+        } else {
+            sk.args([
+                // Search mode
+                "--exact",
+                // Search result
+                "--no-sort",
+                // Interface
+                "--bind=ctrl-z:ignore,btab:up,tab:down",
+                "--cycle",
+                "--keep-right",
+                // Layout
+                "--border=sharp", // rounded edges don't display correctly on some terminals
+                "--height=45%",
+                "--info=inline",
+                "--layout=reverse",
+                // Display
+                "--tabstop=1",
+                // Scripting
+                "--exit-0",
+            ])
+            .enable_preview()
+        }
+        .spawn()
+    }
 }
diff --git a/src/config.rs b/src/config.rs
index 0aeda5c..4978687 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -47,6 +47,10 @@ pub fn fzf_opts() -> Option<OsString> {
     env::var_os("_ZO_FZF_OPTS")
 }
 
+pub fn sk_opts() -> Option<OsString> {
+    env::var_os("_ZO_SK_OPTS")
+}
+
 pub fn maxage() -> Result<Rank> {
     env::var_os("_ZO_MAXAGE").map_or(Ok(10_000.0), |maxage| {
         let maxage = maxage.to_str().context("invalid unicode in _ZO_MAXAGE")?;
diff --git a/src/util.rs b/src/util.rs
index f74acaf..2e3bf4e 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -150,6 +150,136 @@ impl FzfChild {
     }
 }
 
+pub struct Sk(Command);
+
+impl Sk {
+    const ERR_SK_NOT_FOUND: &'static str = "could not find sk, is it installed?";
+
+    pub fn new() -> Result<Self> {
+        // On Windows, CreateProcess implicitly searches the current working
+        // directory for the executable, which is a potential security issue.
+        // Instead, we resolve the path to the executable and then pass it to
+        // CreateProcess.
+        #[cfg(windows)]
+        let program = which::which("sk.exe").map_err(|_| anyhow!(Self::ERR_SK_NOT_FOUND))?;
+        #[cfg(not(windows))]
+        let program = "sk";
+
+        // TODO: check version of sk here.
+
+        let mut cmd = Command::new(program);
+        cmd.args([
+            // Search mode
+            "--delimiter=\t",
+            "--nth=2",
+            // Scripting
+            "--read0",
+        ])
+        .stdin(Stdio::piped())
+        .stdout(Stdio::piped());
+
+        Ok(Sk(cmd))
+    }
+
+    pub fn enable_preview(&mut self) -> &mut Self {
+        // Previews are only supported on UNIX.
+        if !cfg!(unix) {
+            return self;
+        }
+
+        self.args([
+            // Non-POSIX args are only available on certain operating systems.
+            if cfg!(any(target_os = "linux", target_os = "cygwin")) {
+                r"--preview=\command -p ls -Cp --color=always --group-directories-first {2..}"
+            } else {
+                r"--preview=\command -p ls -Cp {2..}"
+            },
+            // Rounded edges don't display correctly on some terminals.
+            "--preview-window=down,30%,sharp",
+        ])
+        .envs([
+            // Enables colorized `ls` output on macOS / FreeBSD.
+            ("CLICOLOR", "1"),
+            // Forces colorized `ls` output when the output is not a
+            // TTY (like in sk's preview window) on macOS /
+            // FreeBSD.
+            ("CLICOLOR_FORCE", "1"),
+            // Ensures that the preview command is run in a
+            // POSIX-compliant shell, regardless of what shell the
+            // user has selected.
+            ("SHELL", "sh"),
+        ])
+    }
+
+    pub fn args<I, S>(&mut self, args: I) -> &mut Self
+    where
+        I: IntoIterator<Item = S>,
+        S: AsRef<OsStr>,
+    {
+        self.0.args(args);
+        self
+    }
+
+    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Self
+    where
+        K: AsRef<OsStr>,
+        V: AsRef<OsStr>,
+    {
+        self.0.env(key, val);
+        self
+    }
+
+    pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Self
+    where
+        I: IntoIterator<Item = (K, V)>,
+        K: AsRef<OsStr>,
+        V: AsRef<OsStr>,
+    {
+        self.0.envs(vars);
+        self
+    }
+
+    pub fn spawn(&mut self) -> Result<SkChild> {
+        match self.0.spawn() {
+            Ok(child) => Ok(SkChild(child)),
+            Err(e) if e.kind() == io::ErrorKind::NotFound => bail!(Self::ERR_SK_NOT_FOUND),
+            Err(e) => Err(e).context("could not launch sk"),
+        }
+    }
+}
+
+pub struct SkChild(Child);
+
+impl SkChild {
+    pub fn write(&mut self, dir: &Dir, now: Epoch) -> Result<Option<String>> {
+        let handle = self.0.stdin.as_mut().unwrap();
+        match write!(handle, "{}\0", dir.display().with_score(now).with_separator('\t')) {
+            Ok(()) => Ok(None),
+            Err(e) if e.kind() == io::ErrorKind::BrokenPipe => self.wait().map(Some),
+            Err(e) => Err(e).context("could not write to sk"),
+        }
+    }
+
+    pub fn wait(&mut self) -> Result<String> {
+        // Drop stdin to prevent deadlock.
+        mem::drop(self.0.stdin.take());
+
+        let mut stdout = self.0.stdout.take().unwrap();
+        let mut output = String::default();
+        stdout.read_to_string(&mut output).context("failed to read from sk")?;
+
+        let status = self.0.wait().context("wait failed on sk")?;
+        match status.code() {
+            Some(0) => Ok(output),
+            Some(1) => bail!("no match found"),
+            Some(2) => bail!("sk returned an error"),
+            Some(130) => bail!(SilentExit { code: 130 }),
+            Some(128..=254) | None => bail!("sk was terminated"),
+            _ => bail!("sk returned an unknown error"),
+        }
+    }
+}
+
 /// Similar to [`fs::write`], but atomic (best effort on Windows).
 pub fn write(path: impl AsRef<Path>, contents: impl AsRef<[u8]>) -> Result<()> {
     let path = path.as_ref();
